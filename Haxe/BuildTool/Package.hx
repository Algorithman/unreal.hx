import haxe.DynamicAccess;
import sys.FileSystem.*;
import sys.io.File;
using StringTools;

/**
  Packages all the generated .cs files in one or multiple Build.cs / Target.cs files
  so they can be added to the build tool assembly.
  This function is executed in macro context (--macro Package.main ... ) (see build.hxml)
 **/
class Package
{
  public static function main(srcDir:String, mappedFiles:Array<{ name:String, target:String }>)
  {
    var first = mappedFiles[0];
    if (first == null) throw 'Mapped files cannot be empty';
    var dst = File.write(first.target);
    dst.writeString('// Generated by Haxe\n#pragma warning disable\nusing haxe.root;\n');

    var mappedFiles = [ for (m in mappedFiles) m.name => m.target ];

    function recurse(path:String, pack:String)
    {
      for (file in readDirectory(path))
      {
        var p2 = '$path/$file';
        if (isDirectory(p2))
        {
          recurse(p2, pack + file + '.');
        } else if (p2.endsWith('.cs')) {
          var clsName = file.substr(0,-3);
          // var name = pack + clsName;
          var target = mappedFiles[clsName];
          if (target != null)
            mappedFiles.remove(clsName);
          if (clsName != first.name && target != null)
          {
            File.copy(p2, target);
            if (target.indexOf('Templates/Source/') >= 0)
            {
              // check if the templates have been already copied
              // if they are, copy them to the target as well (this is just a convenience
              // feature and might not work if the plugin was installed globally instead of locally)
              // If it doesn't work, however, the new Build.cs file will still be copied by HaxeInit.Build.cs
              // job.
              // so this will only work around the need to compile twice to actually see the changes
              // in the files under the template folder - and is a nice convenience when working on the build
              // scripts

              var otherTarget = target.replace('Templates/Source/', '../../../Source/');
              if (exists(otherTarget))
                File.copy(p2, otherTarget);
            }
          } else {
            var file = File.read(p2, false);
            try
            {
              file.readLine(); // generated by haxe
              var ln = null;
              while(true)
              {
                var ln = file.readLine();
                if (ln.startsWith('using')) // -D no-root
                {
                  // do nothing
                } else if (ln.indexOf('#pragma warning') >= 0) {
                } else {
                  dst.writeString(ln);
                  dst.writeByte('\n'.code);
                }
              }
            }
            catch(e:haxe.io.Eof) {}
          }
        }
      }
    }

    recurse(srcDir, '');
    dst.close();

    var remaining = [ for (k in mappedFiles.keys()) k ];
    if (remaining.length > 0)
      throw 'The following mapped files weren\'t found: $remaining';
  }
}
